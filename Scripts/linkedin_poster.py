"""LinkedIn API poster for the AI Employee vault.

Provides the LinkedInPoster class used by the approval-executing skill
to publish posts to LinkedIn after human approval via the HITL flow.

NOT a watcher â€” does not extend BaseWatcher.

Usage (via approval-executing skill or directly):
    from linkedin_poster import LinkedInPoster
    poster = LinkedInPoster()
    result = poster.post_update("Your post text here")

Setup:
    Run Scripts/linkedin_auth.py once first to obtain and save the access token.

Environment variables (or set in .env):
    LINKEDIN_ACCESS_TOKEN   OAuth bearer token from linkedin_auth.py
    LINKEDIN_PERSON_URN     urn:li:person:<id> from linkedin_auth.py
    DRY_RUN                 If "true", log the post but do not call the API (default: true)
"""

import json
import logging
import os
from pathlib import Path

import requests
from dotenv import load_dotenv

load_dotenv()

logger = logging.getLogger(__name__)

_UGC_POSTS_URL = "https://api.linkedin.com/v2/ugcPosts"
_USERINFO_URL = "https://api.linkedin.com/v2/userinfo"


class LinkedInPoster:
    """Posts text updates to LinkedIn via the UGC Posts API.

    Reads the access token from environment variables or the token file
    generated by linkedin_auth.py. Intended for use by the approval-executing
    skill after a human approves a LinkedIn post draft in Pending_Approval/.

    Attributes:
        access_token: LinkedIn OAuth 2.0 bearer token.
        person_urn: LinkedIn member URN (``urn:li:person:<id>``).
        dry_run: If True, log post text but do not call the LinkedIn API.
    """

    def __init__(
        self,
        access_token: str | None = None,
        person_urn: str | None = None,
        token_path: str | Path | None = None,
    ) -> None:
        """Initialise the LinkedIn poster.

        Args:
            access_token: LinkedIn OAuth bearer token. Falls back to
                LINKEDIN_ACCESS_TOKEN env var, then to the token file.
            person_urn: LinkedIn member URN. Falls back to
                LINKEDIN_PERSON_URN env var, then to the token file.
            token_path: Path to the token JSON file saved by linkedin_auth.py.
                Defaults to Scripts/.linkedin_token.json.

        Raises:
            RuntimeError: If access_token or person_urn cannot be resolved
                from any source.
        """
        self.dry_run: bool = os.environ.get("DRY_RUN", "true").lower() == "true"

        script_dir = Path(__file__).parent
        token_file = Path(token_path) if token_path else script_dir / ".linkedin_token.json"
        stored = self._load_token_file(token_file)

        self.access_token: str = (
            access_token
            or os.environ.get("LINKEDIN_ACCESS_TOKEN", "")
            or stored.get("access_token", "")
        )
        self.person_urn: str = (
            person_urn
            or os.environ.get("LINKEDIN_PERSON_URN", "")
            or stored.get("person_urn", "")
        )

        if not self.access_token:
            raise RuntimeError(
                "LinkedIn access token not found. "
                "Run Scripts/linkedin_auth.py first, then set "
                "LINKEDIN_ACCESS_TOKEN in .env."
            )
        if not self.person_urn:
            raise RuntimeError(
                "LinkedIn person URN not found. "
                "Run Scripts/linkedin_auth.py first, then set "
                "LINKEDIN_PERSON_URN in .env."
            )

        logger.info(
            "LinkedInPoster initialised (urn=%s, dry_run=%s)",
            self.person_urn,
            self.dry_run,
        )

    # ------------------------------------------------------------------
    # Token loading
    # ------------------------------------------------------------------

    def _load_token_file(self, token_file: Path) -> dict:
        """Load token data from the JSON file saved by linkedin_auth.py.

        Args:
            token_file: Path to .linkedin_token.json.

        Returns:
            Dict with access_token and person_urn keys, or empty dict if
            the file does not exist or cannot be parsed.
        """
        if token_file.exists():
            try:
                return json.loads(token_file.read_text(encoding="utf-8"))
            except (json.JSONDecodeError, OSError):
                logger.warning("Could not read LinkedIn token file: %s", token_file)
        return {}

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------

    def post_update(self, text: str) -> dict:
        """Publish a text post to LinkedIn.

        Calls POST /v2/ugcPosts with the provided text. In dry_run mode,
        logs the post body and returns a simulated response without calling
        the API.

        Args:
            text: The post body text. LinkedIn recommends under 3 000 characters
                for best engagement.

        Returns:
            Dict with ``id`` (post ID string) and ``status`` (HTTP status code).
            In dry_run mode, returns ``{"id": "dry_run_post", "dry_run": True}``.

        Raises:
            requests.HTTPError: If the LinkedIn API returns an error response.
        """
        if self.dry_run:
            logger.info(
                "[DRY_RUN] Would publish LinkedIn post (%d chars): %r...",
                len(text),
                text[:80],
            )
            return {"id": "dry_run_post", "dry_run": True}

        payload = {
            "author": self.person_urn,
            "lifecycleState": "PUBLISHED",
            "specificContent": {
                "com.linkedin.ugc.ShareContent": {
                    "shareCommentary": {"text": text},
                    "shareMediaCategory": "NONE",
                }
            },
            "visibility": {
                "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
            },
        }

        resp = requests.post(
            _UGC_POSTS_URL,
            json=payload,
            headers={
                "Authorization": f"Bearer {self.access_token}",
                "Content-Type": "application/json",
                "X-Restli-Protocol-Version": "2.0.0",
            },
            timeout=30,
        )
        resp.raise_for_status()

        post_id = resp.headers.get("x-restli-id", "unknown")
        logger.info("Published LinkedIn post (id=%s, chars=%d)", post_id, len(text))
        return {"id": post_id, "status": resp.status_code}
